import { describe, expect, test, beforeAll } from '@jest/globals';
import { Elysia } from 'elysia';
import { fullSecurityHeaders } from '../../middleware/securityHeaders.js';

describe('Security Headers Tests', () => {
  let app: Elysia;

  beforeAll(async () => {
    // Setup test application with security headers
    app = new Elysia()
      .use(fullSecurityHeaders())
      .get('/test', () => ({ message: 'Test endpoint' }))
      .post('/api/users', ({ body }) => ({ success: true, user: body }))
      .get('/admin/panel', () => ({ admin: true }))
      .post('/api/upload', () => ({ uploaded: true }));
  });

  describe('HSTS (HTTP Strict Transport Security)', () => {
    test('should include HSTS header in production', async () => {
      process.env.NODE_ENV = 'production';
      
      const response = await app.handle(new Request('https://localhost/test'));
      
      const hstsHeader = response.headers.get('Strict-Transport-Security');
      expect(hstsHeader).toBeTruthy();
      expect(hstsHeader).toContain('max-age=');
      expect(hstsHeader).toContain('includeSubDomains');
      expect(hstsHeader).toContain('preload');
    });

    test('should not include HSTS header in development over HTTP', async () => {
      process.env.NODE_ENV = 'development';
      
      const response = await app.handle(new Request('http://localhost/test'));
      
      const hstsHeader = response.headers.get('Strict-Transport-Security');
      expect(hstsHeader).toBeNull();
    });

    test('should include HSTS header for HTTPS in development', async () => {
      process.env.NODE_ENV = 'development';
      
      const response = await app.handle(new Request('https://localhost/test'));
      
      const hstsHeader = response.headers.get('Strict-Transport-Security');
      expect(hstsHeader).toBeTruthy();
    });
  });

  describe('Content Security Policy (CSP)', () => {
    test('should include comprehensive CSP header', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const cspHeader = response.headers.get('Content-Security-Policy');
      expect(cspHeader).toBeTruthy();
      
      // Check key directives
      expect(cspHeader).toContain("default-src 'self'");
      expect(cspHeader).toContain("script-src 'self'");
      expect(cspHeader).toContain("style-src 'self'");
      expect(cspHeader).toContain("img-src 'self' data: https:");
      expect(cspHeader).toContain("connect-src 'self'");
      expect(cspHeader).toContain("font-src 'self' https:");
      expect(cspHeader).toContain("object-src 'none'");
      expect(cspHeader).toContain("base-uri 'self'");
      expect(cspHeader).toContain("form-action 'self'");
      expect(cspHeader).toContain("frame-ancestors 'none'");
      expect(cspHeader).toContain("upgrade-insecure-requests");
    });

    test('should include report-uri for CSP violations', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const cspHeader = response.headers.get('Content-Security-Policy');
      expect(cspHeader).toContain('report-uri /security/csp-report');
    });

    test('should have stricter CSP in production', async () => {
      process.env.NODE_ENV = 'production';
      
      const response = await app.handle(new Request('https://localhost/test'));
      
      const cspHeader = response.headers.get('Content-Security-Policy');
      // In production, should not allow unsafe-inline or unsafe-eval
      expect(cspHeader).not.toContain('unsafe-inline');
      expect(cspHeader).not.toContain('unsafe-eval');
    });
  });

  describe('Permissions Policy', () => {
    test('should include restrictive permissions policy', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const permissionsHeader = response.headers.get('Permissions-Policy');
      expect(permissionsHeader).toBeTruthy();
      
      // Check key restrictions
      expect(permissionsHeader).toContain('geolocation=()');
      expect(permissionsHeader).toContain('microphone=()');
      expect(permissionsHeader).toContain('camera=()');
      expect(permissionsHeader).toContain('fullscreen=(self)');
      expect(permissionsHeader).toContain('payment=()');
      expect(permissionsHeader).toContain('usb=()');
    });
  });

  describe('CORS Headers', () => {
    test('should handle preflight requests', async () => {
      const response = await app.handle(new Request('https://localhost/api/users', {
        method: 'OPTIONS',
        headers: {
          'Origin': 'https://trusted-domain.com',
          'Access-Control-Request-Method': 'POST',
          'Access-Control-Request-Headers': 'Content-Type, Authorization'
        }
      }));
      
      expect(response.status).toBe(200);
      expect(response.headers.get('Access-Control-Allow-Origin')).toBeTruthy();
      expect(response.headers.get('Access-Control-Allow-Methods')).toBeTruthy();
      expect(response.headers.get('Access-Control-Allow-Headers')).toBeTruthy();
      expect(response.headers.get('Access-Control-Max-Age')).toBeTruthy();
    });

    test('should block unauthorized origins in production', async () => {
      process.env.NODE_ENV = 'production';
      
      const response = await app.handle(new Request('https://localhost/api/users', {
        method: 'POST',
        headers: {
          'Origin': 'https://malicious-site.com',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ name: 'Test' })
      }));
      
      const corsOrigin = response.headers.get('Access-Control-Allow-Origin');
      expect(corsOrigin).not.toBe('https://malicious-site.com');
    });

    test('should allow configured origins in production', async () => {
      process.env.NODE_ENV = 'production';
      
      const response = await app.handle(new Request('https://localhost/api/users', {
        method: 'POST',
        headers: {
          'Origin': 'https://bikedreams.com',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ name: 'Test' })
      }));
      
      const corsOrigin = response.headers.get('Access-Control-Allow-Origin');
      expect(corsOrigin).toBe('https://bikedreams.com');
    });

    test('should be more permissive in development', async () => {
      process.env.NODE_ENV = 'development';
      
      const response = await app.handle(new Request('http://localhost/api/users', {
        method: 'POST',
        headers: {
          'Origin': 'http://localhost:3000',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ name: 'Test' })
      }));
      
      const corsOrigin = response.headers.get('Access-Control-Allow-Origin');
      expect(corsOrigin).toBe('http://localhost:3000');
    });
  });

  describe('Security Headers', () => {
    test('should include X-Content-Type-Options', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const header = response.headers.get('X-Content-Type-Options');
      expect(header).toBe('nosniff');
    });

    test('should include X-Frame-Options', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const header = response.headers.get('X-Frame-Options');
      expect(header).toBe('DENY');
    });

    test('should include X-XSS-Protection', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const header = response.headers.get('X-XSS-Protection');
      expect(header).toBe('1; mode=block');
    });

    test('should include Referrer-Policy', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const header = response.headers.get('Referrer-Policy');
      expect(header).toBe('strict-origin-when-cross-origin');
    });

    test('should include Cross-Origin headers', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      expect(response.headers.get('Cross-Origin-Embedder-Policy')).toBe('require-corp');
      expect(response.headers.get('Cross-Origin-Opener-Policy')).toBe('same-origin');
      expect(response.headers.get('Cross-Origin-Resource-Policy')).toBe('same-origin');
    });

    test('should include X-Permitted-Cross-Domain-Policies', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const header = response.headers.get('X-Permitted-Cross-Domain-Policies');
      expect(header).toBe('none');
    });

    test('should include X-DNS-Prefetch-Control', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const header = response.headers.get('X-DNS-Prefetch-Control');
      expect(header).toBe('off');
    });

    test('should remove Server header', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const serverHeader = response.headers.get('Server');
      expect(serverHeader).toBeNull();
    });

    test('should remove X-Powered-By header', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const poweredByHeader = response.headers.get('X-Powered-By');
      expect(poweredByHeader).toBeNull();
    });
  });

  describe('Expect-CT Header', () => {
    test('should include Expect-CT in production', async () => {
      process.env.NODE_ENV = 'production';
      
      const response = await app.handle(new Request('https://localhost/test'));
      
      const expectCtHeader = response.headers.get('Expect-CT');
      expect(expectCtHeader).toBeTruthy();
      expect(expectCtHeader).toContain('max-age=');
      expect(expectCtHeader).toContain('enforce');
      expect(expectCtHeader).toContain('report-uri="/security/ct-report"');
    });

    test('should not include Expect-CT in development', async () => {
      process.env.NODE_ENV = 'development';
      
      const response = await app.handle(new Request('http://localhost/test'));
      
      const expectCtHeader = response.headers.get('Expect-CT');
      expect(expectCtHeader).toBeNull();
    });
  });

  describe('Cache Control Headers', () => {
    test('should include appropriate cache control for sensitive endpoints', async () => {
      const response = await app.handle(new Request('https://localhost/admin/panel'));
      
      const cacheControl = response.headers.get('Cache-Control');
      expect(cacheControl).toContain('no-cache');
      expect(cacheControl).toContain('no-store');
      expect(cacheControl).toContain('must-revalidate');
      
      const pragma = response.headers.get('Pragma');
      expect(pragma).toBe('no-cache');
    });
  });

  describe('Content Type Headers', () => {
    test('should set correct content type for JSON responses', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const contentType = response.headers.get('Content-Type');
      expect(contentType).toContain('application/json');
    });

    test('should include charset in content type', async () => {
      const response = await app.handle(new Request('https://localhost/test'));
      
      const contentType = response.headers.get('Content-Type');
      expect(contentType).toContain('charset=utf-8');
    });
  });

  describe('CSP Report Endpoint', () => {
    test('should handle CSP violation reports', async () => {
      const cspReport = {
        "csp-report": {
          "blocked-uri": "eval",
          "document-uri": "https://localhost/test",
          "original-policy": "default-src 'self'; script-src 'self'",
          "referrer": "",
          "violated-directive": "script-src 'self'"
        }
      };

      const response = await app.handle(new Request('https://localhost/security/csp-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/csp-report' },
        body: JSON.stringify(cspReport)
      }));

      expect(response.status).toBe(204);
    });

    test('should validate CSP report format', async () => {
      const invalidReport = { invalid: 'data' };

      const response = await app.handle(new Request('https://localhost/security/csp-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(invalidReport)
      }));

      expect(response.status).toBe(400);
    });
  });

  describe('CT Report Endpoint', () => {
    test('should handle Certificate Transparency reports', async () => {
      const ctReport = {
        "expect-ct-report": {
          "date-time": "2024-01-01T00:00:00.000Z",
          "hostname": "localhost",
          "port": 443,
          "effective-expiration-date": "2024-12-31T23:59:59.000Z",
          "served-certificate-chain": ["cert1", "cert2"],
          "validated-certificate-chain": ["cert1", "cert2"]
        }
      };

      const response = await app.handle(new Request('https://localhost/security/ct-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/expect-ct-report+json' },
        body: JSON.stringify(ctReport)
      }));

      expect(response.status).toBe(204);
    });

    test('should validate CT report format', async () => {
      const invalidReport = { invalid: 'data' };

      const response = await app.handle(new Request('https://localhost/security/ct-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(invalidReport)
      }));

      expect(response.status).toBe(400);
    });
  });

  describe('Header Injection Protection', () => {
    test('should prevent header injection in responses', async () => {
      const response = await app.handle(new Request('https://localhost/test?callback=alert%281%29'));
      
      // Check that no unexpected headers were injected
      const allHeaders = Array.from(response.headers.entries());
      
      allHeaders.forEach(([key, value]) => {
        expect(key).not.toContain('\r');
        expect(key).not.toContain('\n');
        expect(value).not.toContain('\r\n');
      });
    });

    test('should sanitize user input in headers', async () => {
      const response = await app.handle(new Request('https://localhost/test', {
        headers: {
          'X-Custom-Header': 'value\r\nX-Injected: malicious'
        }
      }));
      
      // Should not reflect the injected header
      expect(response.headers.get('X-Injected')).toBeNull();
    });
  });

  describe('Environment-specific Headers', () => {
    test('should apply development-specific headers', async () => {
      process.env.NODE_ENV = 'development';
      
      const response = await app.handle(new Request('http://localhost/test'));
      
      // More permissive CSP in development
      const csp = response.headers.get('Content-Security-Policy');
      expect(csp).toContain("'unsafe-eval'");
    });

    test('should apply production-specific headers', async () => {
      process.env.NODE_ENV = 'production';
      
      const response = await app.handle(new Request('https://localhost/test'));
      
      // Stricter headers in production
      expect(response.headers.get('Strict-Transport-Security')).toBeTruthy();
      expect(response.headers.get('Expect-CT')).toBeTruthy();
      
      // Stricter CSP
      const csp = response.headers.get('Content-Security-Policy');
      expect(csp).not.toContain("'unsafe-eval'");
      expect(csp).not.toContain("'unsafe-inline'");
    });
  });

  describe('Header Consistency', () => {
    test('should apply headers consistently across endpoints', async () => {
      const endpoints = ['/test', '/api/users', '/admin/panel'];
      
      for (const endpoint of endpoints) {
        const response = await app.handle(new Request(`https://localhost${endpoint}`));
        
        // Core security headers should be present
        expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');
        expect(response.headers.get('X-Frame-Options')).toBe('DENY');
        expect(response.headers.get('Content-Security-Policy')).toBeTruthy();
        expect(response.headers.get('Permissions-Policy')).toBeTruthy();
      }
    });

    test('should handle different HTTP methods consistently', async () => {
      const methods = ['GET', 'POST', 'PUT', 'DELETE'];
      
      for (const method of methods) {
        const response = await app.handle(new Request('https://localhost/test', {
          method,
          body: method !== 'GET' ? JSON.stringify({}) : undefined,
          headers: method !== 'GET' ? { 'Content-Type': 'application/json' } : undefined
        }));
        
        // Security headers should be present regardless of method
        expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');
        expect(response.headers.get('X-Frame-Options')).toBe('DENY');
      }
    });
  });

  describe('Performance Impact', () => {
    test('should not significantly impact response time', async () => {
      const startTime = Date.now();
      
      const requests = Array(100).fill(null).map(() => 
        app.handle(new Request('https://localhost/test'))
      );
      
      await Promise.all(requests);
      
      const endTime = Date.now();
      const duration = endTime - startTime;
      const avgResponseTime = duration / 100;
      
      // Should handle 100 requests with headers in reasonable time
      expect(avgResponseTime).toBeLessThan(10); // Less than 10ms per request on average
      
      console.log(`Average response time with security headers: ${avgResponseTime}ms`);
    });
  });
});
