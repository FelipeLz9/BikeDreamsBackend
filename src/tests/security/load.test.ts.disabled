import { describe, expect, test, beforeAll, afterAll } from '@jest/globals';
import { Elysia } from 'elysia';
import { fullSecurityHeaders } from '../../middleware/securityHeaders.js';
import { authSecurityMiddleware } from '../../middleware/strictSecurity.js';
import { fullValidationPlugin } from '../../plugins/validationPlugin.js';
import { SecurityLogger } from '../../services/securityLogger.js';

describe('Security Load Testing Suite', () => {
  let app: Elysia;
  let securityLogger: SecurityLogger;

  beforeAll(async () => {
    securityLogger = SecurityLogger.getInstance();
    
    // Setup test application with full security stack
    app = new Elysia()
      .use(fullSecurityHeaders())
      .use(authSecurityMiddleware())
      .use(fullValidationPlugin({ detectMalicious: true, strictMode: true }))
      .post('/auth/login', ({ body, validateBody }) => {
        const schema = { parse: (data: any) => data };
        const validatedBody = validateBody(schema, body);
        return { success: true, token: 'fake-jwt-token' };
      })
      .post('/api/users', ({ body, validateBody }) => {
        const schema = { parse: (data: any) => data };
        const validatedBody = validateBody(schema, body);
        return { success: true, user: validatedBody };
      })
      .get('/api/data', ({ query }) => {
        return { success: true, data: query };
      })
      .post('/api/upload', () => {
        return { success: true, uploaded: true };
      });
  });

  describe('Rate Limiting Tests', () => {
    test('should handle burst requests gracefully', async () => {
      const burstSize = 50;
      const requests = Array(burstSize).fill(null).map((_, index) => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.1.100' // Same IP for rate limiting
          },
          body: JSON.stringify({
            name: `User ${index}`,
            email: `user${index}@example.com`
          })
        }))
      );

      const responses = await Promise.all(requests);
      
      // Should start rate limiting after initial burst
      const successfulRequests = responses.filter(r => r.status === 200);
      const rateLimitedRequests = responses.filter(r => r.status === 429);
      
      // Should have some successful requests but also rate limiting
      expect(successfulRequests.length).toBeGreaterThan(0);
      expect(successfulRequests.length).toBeLessThan(burstSize);
      expect(rateLimitedRequests.length).toBeGreaterThan(0);
    });

    test('should apply different rate limits per endpoint', async () => {
      const authRequests = Array(20).fill(null).map(() => 
        app.handle(new Request('http://localhost/auth/login', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.1.101'
          },
          body: JSON.stringify({
            username: 'testuser',
            password: 'password123'
          })
        }))
      );

      const dataRequests = Array(100).fill(null).map(() => 
        app.handle(new Request('http://localhost/api/data', {
          method: 'GET',
          headers: { 
            'X-Forwarded-For': '192.168.1.102'
          }
        }))
      );

      const [authResponses, dataResponses] = await Promise.all([
        Promise.all(authRequests),
        Promise.all(dataRequests)
      ]);

      // Auth endpoint should be more restrictive
      const authRateLimited = authResponses.filter(r => r.status === 429);
      const dataRateLimited = dataResponses.filter(r => r.status === 429);

      expect(authRateLimited.length).toBeGreaterThan(0);
      // Data endpoint should be less restrictive initially
    });

    test('should reset rate limits after time window', async () => {
      const initialRequests = Array(10).fill(null).map(() => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.1.103'
          },
          body: JSON.stringify({
            name: 'Test User',
            email: 'test@example.com'
          })
        }))
      );

      await Promise.all(initialRequests);

      // Wait for rate limit window to reset (simulate time passing)
      await new Promise(resolve => setTimeout(resolve, 1000));

      const resetRequests = Array(5).fill(null).map(() => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.1.103'
          },
          body: JSON.stringify({
            name: 'Reset Test User',
            email: 'reset@example.com'
          })
        }))
      );

      const responses = await Promise.all(resetRequests);
      const successfulRequests = responses.filter(r => r.status === 200);
      
      // Should allow some requests after reset
      expect(successfulRequests.length).toBeGreaterThan(0);
    });
  });

  describe('DDoS Protection Tests', () => {
    test('should detect and block coordinated attacks', async () => {
      const attackIPs = ['10.0.0.1', '10.0.0.2', '10.0.0.3', '10.0.0.4', '10.0.0.5'];
      const requestsPerIP = 30;

      const attackRequests = attackIPs.flatMap(ip => 
        Array(requestsPerIP).fill(null).map(() => 
          app.handle(new Request('http://localhost/api/users', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Forwarded-For': ip
            },
            body: JSON.stringify({
              name: 'Attack User',
              email: 'attack@example.com'
            })
          }))
        )
      );

      const responses = await Promise.all(attackRequests);
      
      // Should block a significant portion of attack requests
      const blockedRequests = responses.filter(r => r.status >= 400);
      const blockedPercentage = (blockedRequests.length / responses.length) * 100;
      
      expect(blockedPercentage).toBeGreaterThan(50); // Should block at least 50% of attack
    });

    test('should handle large payload attacks', async () => {
      const largePayload = 'x'.repeat(1024 * 1024); // 1MB payload
      
      const requests = Array(10).fill(null).map(() => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.1.104'
          },
          body: JSON.stringify({
            name: 'Large Payload User',
            description: largePayload
          })
        }))
      );

      const responses = await Promise.all(requests);
      
      // Should reject large payloads
      responses.forEach(response => {
        expect(response.status).not.toBe(200);
        expect([400, 413, 429]).toContain(response.status);
      });
    });

    test('should handle malformed request floods', async () => {
      const malformedRequests = Array(50).fill(null).map((_, index) => {
        const malformedBodies = [
          '{"name": "test"', // Incomplete JSON
          '{"name": "test", "invalid": }', // Invalid JSON syntax
          '{"name": ' + 'x'.repeat(10000) + '}', // Extremely long value
          '{' + '"key":'.repeat(1000) + '"value"}', // Deeply nested structure
          JSON.stringify({ name: null, data: undefined }), // Invalid values
        ];
        
        return app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': `192.168.2.${index % 10}`
          },
          body: malformedBodies[index % malformedBodies.length]
        }));
      });

      const responses = await Promise.all(malformedRequests);
      
      // Should handle malformed requests gracefully without crashing
      responses.forEach(response => {
        expect(response.status).toBeDefined();
        expect(response.status).toBeLessThan(500);
      });
    });
  });

  describe('Stress Testing', () => {
    test('should handle concurrent validation requests', async () => {
      const concurrentRequests = 100;
      const maliciousPayloads = [
        '<script>alert("xss")</script>',
        "'; DROP TABLE users; --",
        '../../../etc/passwd',
        '{{7*7}}',
        '${7*7}',
        '`whoami`'
      ];

      const requests = Array(concurrentRequests).fill(null).map((_, index) => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': `192.168.3.${index % 50}`
          },
          body: JSON.stringify({
            name: maliciousPayloads[index % maliciousPayloads.length],
            email: `test${index}@example.com`,
            bio: maliciousPayloads[(index + 1) % maliciousPayloads.length]
          })
        }))
      );

      const startTime = Date.now();
      const responses = await Promise.all(requests);
      const endTime = Date.now();
      const duration = endTime - startTime;

      // All requests should be blocked or sanitized
      responses.forEach(response => {
        if (response.status === 200) {
          // If passed, should be sanitized
          expect(response.status).toBe(200);
        } else {
          // Should be blocked
          expect(response.status).toBe(400);
        }
      });

      // Should handle requests in reasonable time (less than 10 seconds)
      expect(duration).toBeLessThan(10000);
      
      console.log(`Processed ${concurrentRequests} requests in ${duration}ms`);
      console.log(`Average: ${duration / concurrentRequests}ms per request`);
    });

    test('should maintain performance under mixed attack patterns', async () => {
      const mixedAttacks = [
        // XSS attempts
        ...Array(20).fill(null).map(() => ({
          endpoint: '/api/users',
          method: 'POST' as const,
          payload: { name: '<script>alert("xss")</script>', email: 'test@example.com' }
        })),
        
        // SQL injection attempts
        ...Array(20).fill(null).map(() => ({
          endpoint: '/auth/login',
          method: 'POST' as const,
          payload: { username: "'; DROP TABLE users; --", password: 'password' }
        })),
        
        // Path traversal attempts
        ...Array(20).fill(null).map(() => ({
          endpoint: '/api/users',
          method: 'POST' as const,
          payload: { filename: '../../../etc/passwd', name: 'test' }
        })),
        
        // Command injection attempts
        ...Array(20).fill(null).map(() => ({
          endpoint: '/api/users',
          method: 'POST' as const,
          payload: { command: '; ls -la', name: 'test' }
        })),
        
        // Large payload attacks
        ...Array(10).fill(null).map(() => ({
          endpoint: '/api/users',
          method: 'POST' as const,
          payload: { name: 'test', data: 'x'.repeat(50000) }
        })),
      ];

      const requests = mixedAttacks.map((attack, index) => 
        app.handle(new Request(`http://localhost${attack.endpoint}`, {
          method: attack.method,
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': `192.168.4.${index % 20}`
          },
          body: JSON.stringify(attack.payload)
        }))
      );

      const startTime = Date.now();
      const responses = await Promise.all(requests);
      const endTime = Date.now();
      const duration = endTime - startTime;

      // Should block or handle all attacks
      const blockedRequests = responses.filter(r => r.status === 400);
      const blockedPercentage = (blockedRequests.length / responses.length) * 100;

      expect(blockedPercentage).toBeGreaterThan(80); // Should block most attacks
      
      // Performance should remain reasonable
      expect(duration).toBeLessThan(15000); // Less than 15 seconds
      
      console.log(`Mixed attack test: ${blockedPercentage}% blocked in ${duration}ms`);
    });
  });

  describe('Memory and Resource Tests', () => {
    test('should not leak memory under attack', async () => {
      const initialMemory = process.memoryUsage().heapUsed;
      
      // Simulate sustained attack
      for (let round = 0; round < 5; round++) {
        const requests = Array(50).fill(null).map(() => 
          app.handle(new Request('http://localhost/api/users', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Forwarded-For': '192.168.5.1'
            },
            body: JSON.stringify({
              name: '<script>' + 'x'.repeat(1000) + '</script>',
              data: 'y'.repeat(10000)
            })
          }))
        );
        
        await Promise.all(requests);
        
        // Force garbage collection if available
        if (global.gc) {
          global.gc();
        }
      }
      
      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = finalMemory - initialMemory;
      const memoryIncreasePercent = (memoryIncrease / initialMemory) * 100;
      
      console.log(`Memory usage increased by ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB (${memoryIncreasePercent.toFixed(2)}%)`);
      
      // Memory increase should be reasonable (less than 100MB or 50% increase)
      expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024); // 100MB
      expect(memoryIncreasePercent).toBeLessThan(50); // 50%
    });

    test('should handle file upload flood gracefully', async () => {
      const fileUploadRequests = Array(30).fill(null).map((_, index) => {
        const formData = new FormData();
        const fakeFile = new Blob(['x'.repeat(100000)], { type: 'text/plain' });
        formData.append('file', fakeFile, `test${index}.txt`);
        
        return app.handle(new Request('http://localhost/api/upload', {
          method: 'POST',
          headers: {
            'X-Forwarded-For': `192.168.6.${index % 10}`
          },
          body: formData
        }));
      });

      const responses = await Promise.all(fileUploadRequests);
      
      // Should handle file uploads without crashing
      responses.forEach(response => {
        expect(response.status).toBeDefined();
        expect(response.status).toBeLessThan(500);
      });
      
      // Should rate limit file uploads
      const rateLimited = responses.filter(r => r.status === 429);
      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });

  describe('Security Event Logging Under Load', () => {
    test('should log security events efficiently under high load', async () => {
      const attackRequests = Array(100).fill(null).map((_, index) => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': `192.168.7.${index % 20}`
          },
          body: JSON.stringify({
            name: `<script>alert("attack${index}")</script>`,
            email: `'; DELETE FROM users WHERE id=${index}; --`,
            path: `../../../etc/passwd${index}`
          })
        }))
      );

      const startTime = Date.now();
      await Promise.all(attackRequests);
      const endTime = Date.now();
      
      // Wait a bit for logging to complete
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Logging should not significantly impact performance
      const duration = endTime - startTime;
      expect(duration).toBeLessThan(5000); // Should complete in under 5 seconds
      
      console.log(`Logged 100 security events in ${duration}ms`);
    });

    test('should handle log rotation under sustained attacks', async () => {
      // Simulate sustained attack over time to trigger log rotation
      for (let batch = 0; batch < 10; batch++) {
        const batchRequests = Array(20).fill(null).map((_, index) => 
          app.handle(new Request('http://localhost/api/users', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Forwarded-For': `192.168.8.${index}`
            },
            body: JSON.stringify({
              attack_type: 'xss',
              payload: `<script>console.log("batch${batch}_${index}")</script>`
            })
          }))
        );
        
        await Promise.all(batchRequests);
        
        // Small delay between batches
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      // Should complete without errors
      expect(true).toBe(true);
    });
  });

  describe('Recovery and Resilience Tests', () => {
    test('should recover from attack floods', async () => {
      // Phase 1: Heavy attack
      const attackRequests = Array(200).fill(null).map(() => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.9.1'
          },
          body: JSON.stringify({
            name: '<script>alert("flood")</script>',
            data: 'x'.repeat(50000)
          })
        }))
      );

      await Promise.all(attackRequests);
      
      // Phase 2: Wait for systems to recover
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Phase 3: Normal requests should work
      const normalRequests = Array(10).fill(null).map(() => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.9.100' // Different IP
          },
          body: JSON.stringify({
            name: 'Normal User',
            email: 'normal@example.com'
          })
        }))
      );

      const responses = await Promise.all(normalRequests);
      const successfulRequests = responses.filter(r => r.status === 200);
      
      // Should allow legitimate traffic after attack
      expect(successfulRequests.length).toBeGreaterThan(5);
    });

    test('should maintain security during high CPU usage', async () => {
      // Create CPU-intensive payload processing
      const cpuIntensiveRequests = Array(20).fill(null).map(() => 
        app.handle(new Request('http://localhost/api/users', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Forwarded-For': '192.168.10.1'
          },
          body: JSON.stringify({
            name: 'x'.repeat(10000),
            data: JSON.stringify(Array(1000).fill(null).map((_, i) => ({
              id: i,
              value: `<script>alert("${i}")</script>`,
              nested: Array(100).fill(`'; DROP TABLE t${i}; --`)
            })))
          })
        }))
      );

      const responses = await Promise.all(cpuIntensiveRequests);
      
      // Should still block attacks even under CPU stress
      responses.forEach(response => {
        expect(response.status).toBe(400); // Should be blocked
      });
    });
  });

  afterAll(async () => {
    // Cleanup resources
    await new Promise(resolve => setTimeout(resolve, 100));
  });
});
